SKARTSILAS DAMIANOS 
ΣΚΑΡΤΣΙΛΑΣ ΔΑΜΙΑΝΟΣ 2Η ΕΡΓΑΣΙΑ ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ ΣΥΣΤΗΜΑΤΟΣ 2024
1115201800180

Εντολή μεταγλώττισης: make
Για να μεταγλώττιστεί το progDelay το μεταγλώττίζουμε ξεχωριστά: g++ progDelay.cpp -o progDelay
Εντολή εκτέλεσης server: ./bin/jobExecutorServer 65345 4 3

	: εδώ έχουμε επιλέξει το port 65345 , 4 buffefSize και 3 worker
Εντολή εκτέλεσης commander:
 ./bin/jobCommander linux10.di.uoa.gr 65345 issueJob ./tests/progDelay 20
	
: εδώ θα στείλουμε στον server την εντολή να τρέξει το εκτελέσιμο progDelay με ορισμα 20

Λειτουργικότητα και γενικότερη περιγραφή

--------------------------------------------JobExecutorServer---------------------------------------
Δομές που υλοποιήθηκαν : 

Ενταμιευτής : Με χρήση της STL δημιουργήθηκε μία ουρά <queue>  τύπου Job . Η  Job είναι class όπου κάθε αντικείμενο αντιπροσωπεύει μια εργασία. 
Δομή ThreadArgs: Για να αποφευχθεί η δήλωση των κοινών πόρων globally δημιουργήθηκε η αντίστοιχη δομή. Στην ουσία είναι μια δομή που μπεριέχει pointers διάφορων τύπων. Οι συγκεκριμένοι pointers δείχνουν στα κοινά recources και στα mutexes και cond vars που θα έχουν πρόσβαση όλα τα threads.

Σημείωση: Ο Buffer είναι στην ουσία μια ουρά η οποία δεν είναι στατικη. όμως η στατικότητα εξασφαλίζεται μέσω της μεταβλητής BufferSize όπου δεν επιτρέπει για παραπάνω εντολές να εισαχτούν στον Buffer.
Threads : 

Main Thread: είναι η main( ) συνάρτηση του προγράμματος .
Εκεί ανοίγει το socket με το οποίο θα επικοινωνεί ο κάθε client με τον Server, και γίνονται αποδεκτές οι συνδέσεις (accept)
Εκεί δηλώνονται όλα τα κοινά resources , δημιουργούνται τα threads (controller & worker). 

Worker Thread:  Υπηρετεί την ζητούμενη λειτουργικότητα. Κάθε ένα worker thread αναλαμβάνει μια Job για να την εκτελέσει. Γίνεται χρήση mutexes και cond vars προκειμένου μην υπάρχει busy waiting ή επιπλοκή στην πρόσβαση και τη χρήση κοινών resources. 

Σημείωση: Η ανακατεύθυνση της εξόδου κάθε εντολής δεν υλοποιήθηκε. Ωστόσο επειδή έγινε προσπάθεια και σχεδόν ολοκληρώθηκε ο αντίστοιχος κώδικας έχει μπει σε comment. 
Το πρόβλημα ήταν ότι η εργασία δεν γυρνούσε στο σωστό client αλλά σε διαφορετικό.

Controller thread: Υλοποιεί την απαιτούμενη λειτουργικότητα. Οι υλοποιήσεις των εντολών (poll stop exit κλπ)  είναι ορατές στο if condition statement. Εκεί επίσης ειδοποιείται ένα worker thread στην περίπτωση που άλλαξε για παράδειγμα το concurrencyLevel μέσω pthread_cond_signal(cv_wrkr);

--------------------------------------------JobCommander---------------------------------------------------

Στην main ύστερα από μία βασική διαχείριση λανθασμένου input ανοίγεται ένα σοκετ και κατόπιν στέλνεται η εντολή στον server, ο οποίος είναι ήδη ενεργός. Αν δεν είναι ανοιχτός εμφανίζεται αντίστοιχο μήνυμα αποτυχημένης σύνδεσης. Γενικά η επικοινωνία μεταξύ client-server και στα δύο προγράμματα γίνεται μέσω send( ). Όπως φαίνεται ππριν το κλείσιμο της main υπάρχει κομμάτι κώδικα ο οποίος είναι υπό comment. Αυτό γιατί ενώ είχε υλοποιηθεί η λειτουργικότητα αποδοχής δεύτερου μηνύματος (αυτό του output) δεν λειτουργούσε όπως έπρεπε και εμπόδιζε την σωστή λειτουργικότητα (το συγκεκριμένο εξηγήθηκε και πιο πάνω) .

struct addrinfo hints, *res :
Η struct addrinfo είναι μια δομή που χρησιμοποιείται για την αποθήκευση πληροφοριών σχετικά με μια διεύθυνση socket. Η struct addrinfo hints είναι μια δομή που χρησιμοποιείται για την καθοδήγηση της λειτουργίας getaddrinfo(). Η struct addrinfo *res είναι ένα δείκτη που δείχνει σε μια λίστα δομών addrinfo που περιέχουν πληροφορίες σχετικά με τη διεύθυνση socket που επιστρέφεται από τη λειτουργία getaddrinfo().

Για να τερματίσουμε τον server, εισάγουμε την εντολή:
./bin/jobCommander linux10.di.uoa.gr 65345 exit